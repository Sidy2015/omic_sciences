---
layout: page
title: Analyzing DNA methylation data 1
---

```{r options, echo=FALSE}
library(knitr)

```
# DNA Methylation Data Analysis
Fir the the last part of this section you will need the data available for download fron this github site: [tcgaMethylationSubset](https://github.com/genomicsclass/tcgaMethylationSubset) 

<a href="https://github.com/genomicsclass/tcgaMethylationSubset/archive/master.zip" target="[object Object]">ZIP</a>
http://genomicsclass.github.io/book/
In this unit we will show an example of analyzing methylation data. We will use colon cancer data from TCGA. The data was created with the Illumina 450K array and we have already processed the raw data to create matrix with methylation measurements. The script that creates these ojects is here: https://github.com/genomicsclass/labs/blob/master/Rscripts/read_tcga_meth.R

Let's begin by loading the data
```{r,message=FALSE}
#devtools::install_github("genomicsclass/coloncancermeth")
library(S4Vectors)
library(coloncancermeth)
data(coloncancermeth)
```

We know have three tables one containing the methylation data, one with information about the samples or columns of the data matrix, and granges object with the genomic location of the CpGs represetned in the rows of the data matrix

```{r}
dim(meth) ##this is the methylation data
dim(pd) ##this is sample information
length(gr)
```

The `pd` object includes clinical information. One the columns tells us if the sample is from colon cancer or from normal tissue

```{r}
colnames(pd)
table(pd$Status)
normalIndex <- which(pd$Status=="normal")
cancerlIndex <- which(pd$Status=="cancer")
```


Let's start by taking a quick look at the distribution of methylation measurements for the normal samples:

```{r}
i=normalIndex[1]
plot(density(meth[,i],from=0,to=1),main="",ylim=c(0,3),type="n")
for(i in normalIndex){
  lines(density(meth[,i],from=0,to=1),col=1)
}
### Add the cancer samples
for(i in cancerlIndex){
  lines(density(meth[,i],from=0,to=1),col=2)
}
```

We are interested in finding regions of the genome that are different between cancer and normal samples. Furthermore, we want regions that are consistenly different therefore we can treat this as an inference problem. We can compute a t-statistic for each CpG:



Here we show the basic steps for performing a `limma` analysis. Note that the `limma` package is very powerful, and has hundreds of pages of documentation which we cannot cover in this course, however we recommend that users wanting to explore further should check out this guide. The reference is [Smyth 2004](#foot), listed in the footnotes.

## limma steps



The following three steps perform the basic `limma` analysis. We specify `coef=2` because we are interested in the difference between groups, not the intercept.

```{r,message=FALSE}
library(limma)
X<-model.matrix(~pd$Status)
fit<-lmFit(meth,X)
eb <- eBayes(fit)
```

What happens here is a common limma (and friends) workflow.  First, the comparison of interest (and the design of the experiment) is defined through a so-called "design matrix".  This matrix basically encompasses everything we know about the design; in this case there are two groups (we have more to say on the design below).  Next, the model is fitted.  This is followed by borrowing strength across genes using a so-called empirical Bayes procedure (this is the step in limma which really works wonders).  

To look at t he results on would normally call the `topTable()` function which lists the top differentially expressed genes to return the comparison of interest to summarize. We not going to do that here because we have so many coefficients.


A volcano plot reveals many differences:

```{r}
library(rafalib)
splot(fit$coef[,2],-log10(eb$p.value[,2]),xlab="Effect size",ylab="-log10 p-value")
```

If we have reason to believe for DNA methylation to have an effect on gene expression a region of the genome needs to be affected, not just a single CpG, we should look beyond. Here is plot of the region surrounding the top hit:

```{r,message=FALSE}
library(GenomicRanges)
i <- which.min(eb$p.value[,2])
middle <- gr[i,]
Index<-gr%over%(middle+10000)
cols=ifelse(pd$Status=="normal",1,2)
chr=as.factor(seqnames(gr))
pos=start(gr)

plot(pos[Index],fit$coef[Index,2],type="b",xlab="genomic location",ylab="difference")
matplot(pos[Index],meth[Index,],col=cols,xlab="genomic location")
```

We can search for these regions explicitly instead of searching for single points, as explained by Jaffe and Irizarry (2012) [http://www.ncbi.nlm.nih.gov/pubmed/22422453]. 

If we are going to perform regional analysis we first have to define a region. But one issue is that not only do we have to separate the analysis by chromosome but that within each chromosome we usually have big gaps creating subgroups of regions to be analyzed.

```{r}
chr1Index <- which(chr=="chr1")
hist(log10(diff(pos[chr1Index])),main="",xlab="log 10 method")
```

We can create groups in the following way.

```{r,message=FALSE}
# BiocManager::install("bumphunter")
library(bumphunter)
cl=clusterMaker(chr,pos,maxGap=500)
table(table(cl)) ##shows the number of regions with 1,2,3, ... points in them
```


Now let's consider two example regions:

```{r}
###Select the region with the smallest value
Index<- which(cl==cl[which.min(fit$coef[,2])])
matplot(pos[Index],meth[Index,],col=cols,pch=1,xlab="genomic location",ylab="methylation")

x1=pos[Index]
y1=fit$coef[Index,2]
plot(x1,y1,xlab="genomic location",ylab="Methylation difference",ylim=c(-1,1))
abline(h=0,lty=2)
abline(h=c(-.1,.1),lty=2)
```

This region shows only a single CpG as different. In contrast, notice this region:

```{r}
Index=which(cl==72201) ##we know this is a good example from analysis we have already performed

matplot(pos[Index],meth[Index,],col=cols,pch=1,xlab="genomic location",ylab="methylation")

x2=pos[Index]
y2=fit$coef[Index,2]
plot(x2,y2,xlab="genomic location",ylab="Methylation difference",ylim=c(-1,1))
abline(h=0,lty=2)
abline(h=c(-.1,.1),lty=2)
```

<a name="DMR"></a>

If we are interested in prioritizing regions over single points, we need an alternative approach. If we assume that the real signal is smooth, we could use statistical smoothing techniques such as loess. Here is an example two regions above

```{r}
lfit <- loess(y1~x1,degree=1,family="symmetric",span=1/2)
plot(x1,y1,xlab="genomic location",ylab="Methylation difference",ylim=c(-1,1))
abline(h=c(-.1,0,.1),lty=2)
lines(x1,lfit$fitted,col=2)

lfit <- loess(y2~x2,degree=1,family="symmetric",span=1/2)
plot(x2,y2,xlab="genomic location",ylab="Methylation difference",ylim=c(-1,1))
abline(h=c(-.1,0,.1),lty=2)
lines(x2,lfit$fitted,col=2)
```


The bumphunter automates this procedure:

```{r}
res<-bumphunter(meth,X,chr=chr,pos=pos,cluster=cl,cutoff=0.1,B=0)
tab<-res$table
```

We now have a list of regions instead of single points. Here we look at the region with the highest rank if we order by area:

```{r}
Index=(tab[1,7]-3):(tab[1,8]+3)
matplot(pos[Index],meth[Index,,drop=TRUE],col=cols,pch=1,xlab="genomic location",ylab="Methylation",ylim=c(0,1))
plot(pos[Index],res$fitted[Index,1],xlab="genomic location",ylab="Methylation difference",ylim=c(-1,1))
abline(h=c(-0.1,0,.1),lty=2)
```

The function also allows from smoothing and permutation based inference for the regions. However, we do not recommend running the function with these options without the ability to parallelize. 


######################################################################################################################################

##Reading 450K idat files with the minfi package

In this unit we will demonstrate how to read idat files from the illumina 450K DNA methylation array. We make use the the Bioconductor minfi package [cite 24478339].

```{r}
# BiocManager::install(c("minfi","IlluminaHumanMethylation450kmanifest","IlluminaHumanMethylation450kanno.ilmn12.hg19"))
library(minfi)
```

The first step is to determine the basename of the idat files. Note that for each sample we have two files: one for red and green channels respectively. These files are found here: <https://github.com/genomicsclass/rawdata/tree/master/idats>

```{r}
path <- "idats"
list.files(path)
```

Let's start by reading in the csv file, which contains clinical information. This has one row for each sample and one of the columns includes the "basenames" for the files.

```{r}
targets<-read.csv("idats/targets.csv",as.is=TRUE)
names(targets)
targets$Basename
```

To make this script work in any working directory  we can edit that column to contain the absolute paths. Then we are ready to read in the raw data with `read.metharray`:

```{r}
targets$Basename <- file.path(path,targets$Basename)
rgset <- read.metharray(targets$Basename,verbose=TRUE)
pData(rgset)<-as(targets, "DataFrame")
```

We now have the raw data, red and green intensities which we have access to:
```{r}
dim(getRed(rgset))
dim(getGreen(rgset))
```

If you are not interested in developing preprocessing algorithms then you can use the built in preprocessing algorithm and go straight to an object that give you access to methylation estimates:

```{r}
mset <- preprocessIllumina(rgset)
```

This performs the default preprocessing algorithm developed by Illumina. However, for this to be useful, we want to have the locations of each CpG, and to do that we need map the CpGs to genome. minfi keeps this information modular so that when the genome annotation gets updated, one can easily change the mapping. 
```{r}
mset <- mapToGenome(mset)
```

Now we are ready to obtain the methylation values and CpG locations.
 
```{r}
dim(getBeta(mset,type="Illumina")) ##the argument type="Illumina" gives us default procedure
head(granges(mset))
```

For every row of the beta matrix, you have the location of the probe

We can also use functions such as `getSex` and `getQC` on the mset object:
```{r}
colData(mset)<-getSex(mset)
plotSex(mset)
plot(as.matrix(getQC(mset)))
```

The numbers give you a general idea of the quality control, there is a paper where you can read all about it here:

######################################################################################################################################
##Visualizing methyation data

contributed by HÃ©ctor Corrada Bravo

Here we show how to visualize the results of your methylation data analysis in the [epiviz](http://epiviz.cbcb.umd.edu) interactive
genomics data visualization app. To plot your data there we use the Bioconductor `epivizr` package. 


```{r}
# biocLite("epivizr")
library(epivizr)
```

We assume you already ran the `methylation` lab. The following code is used to populate the environment with the necessary objects. Please see the methylation lab for description of what these functions are doing.

```{r}
library(coloncancermeth)
data(coloncancermeth)
library(limma)
X<-model.matrix(~pd$Status)
fit<-lmFit(meth,X)
eb <- ebayes(fit)
library(bumphunter)
chr=as.factor(seqnames(gr))
pos=start(gr)
cl=clusterMaker(chr,pos,maxGap=500)
res<-bumphunter(meth,X,chr=chr,pos=pos,cluster=cl,cutoff=0.1,B=0)
```

You should therefore have in your environment the following objects:

```{r}
# the result of using limma and eBayes at the single CpG level
head(fit$coef)
head(eb$t)

# the result of running bumphunter
head(res$fitted)
head(res$table)

# the CpG location object
show(gr)
```

`epivizr` uses `GRanges` objects to visualize data, so we'll create a new `GRanges` object containing CpG level
estimates we want to visualize

```{r}
cpgGR <- gr
cpgGR$fitted <- round(res$fitted,digits=3)
```

and make another `GRanges` object containing the `bumphunter` result

```{r}
dmrGR <- with(res$table,GRanges(chr,IRanges(start,end),area=area,value=value))

# let's add an annotation for "hypo-" or "hyper-" methylation (as long as the difference is large enough)
dmrGR$type <- ifelse(abs(dmrGR$value)<0.2, "neither", ifelse(dmrGR$value<0,"hypo","hyper"))
table(dmrGR$type)
```

Now, we are ready to visualize this data on `epiviz`. First start an epiviz session:

```{r,eval=FALSE,echo=TRUE}
mgr <- startEpiviz(workspace="mi9NojjqT1l")
```

```{r,eval=TRUE,echo=FALSE}
# this is here so that the Rmd can be knitted without connecting to browser
# use the command above to actually do this
mgr <- startEpiviz(debug=TRUE, openBrowser=FALSE, nonInteractive=TRUE, tryPorts=TRUE)
mgr$startServer()
```

----

*Windows users* You need to call the `mgr$service()` method to allow the `epiviz` app to connect to your R session:

```{r}
# mgr$service()
```

Non-Windows users don't need to do this.

----

Now, let's add tracks for hypo and hyper methylated regions:

```{r}
hypoTrack <- mgr$addDevice(subset(dmrGR,dmrGR$type=="hypo"), "Hypo-methylated")
hyperTrack <- mgr$addDevice(subset(dmrGR,dmrGR$type=="hyper"), "Hyper-methylated")
```

We can also add the estimated methylation difference as another track:

```{r}
diffTrack <- mgr$addDevice(cpgGR,"Meth difference",type="bp",columns="fitted")
```

Go to your browser and navigate around, search for your favorite gene and take a look at gene expression
looks like around these regions according to the [gene expression barcode](http://www.ncbi.nlm.nih.gov/pubmed/21177656),
which we preloaded when we started `epiviz`. Here's some interesting ones: "MMP10", "TIMP2", "MAGEA12".

<a href="figure/epiviz.png"><img src="figure/epiviz.png" width=600 /></a>

----

*Windows users* Remember to call `mgr$service()` before going to the browser

----

Here's other useful analyses you can do with `epivizr`. Let's make a `SummarizedExperiment` containing CpG-level data we can use for an MA plot

```{r}
colData <- DataFrame(name=c("M","A"))
rownames(colData) <- colData$name

rowData <- gr
rowData$cpg <- names(gr)

cpgSE <- SummarizedExperiment(rowData=rowData,
      assays=SimpleList(ma=cbind(fit$coef[,2],fit$Amean)),
      colData=colData)
```

and add the MA plot:

```{r}
maPlot <- mgr$addDevice(cpgSE,columns=c("A","M"),"cpg MA")
```

<a href="figure/epivizma.png"><img src="figure/epivizma.png" width=600 /></a>

Let's now browse the genome in order through the top 5 found regions in order (by area):

```{r}
slideshowRegions <- dmrGR[1:10,] + 10000
mgr$slideshow(slideshowRegions, n=5)
```

Last thing to do is disconnect the `epiviz` app:

```{r}
mgr$stopServer()
```

There's a lot more you can do with `epiviz`. It's a fairly flexible visualization tool. You can find out more about it in the [epiviz documentation site](http://epiviz.github.io).

Also, `epivizr` has a vignette that's worth checking out:

```{r}
browseVignettes("epivizr")
```

######################################################################################################################################
## Inference Methylation Data
```{r}
##Bioc
library(IlluminaHumanMethylation450kmanifest) ##Bioc
library(doParallel) ##CRAN
library(pkgmaker)
library(rafalib)
```

```{r}
path="/Users/gurinina/Dropbox/Documents/Rprojects/2022_GENOMICS_COURSE/tcgaMethylationSubset"
    # use your own path to downloaded data
targets=read.delim(file.path (path,"targets.txt"),as.is=TRUE)
table(targets$Tissue,targets$Status)
```

For illustration we will read in the normal colon and lung

```{r}
index = which( targets$Status=="normal" & targets$Tissue%in%c("colon","lung") )
targets = targets[index,]
```

```{r}
dat = read.metharray.exp(base=path,targets = targets, verbose=TRUE)
dat = preprocessIllumina(dat)
dat = mapToGenome(dat)
dat = ratioConvert(dat,type="Illumina")
```

```{r}
library(doParallel)
detectCores()
registerDoParallel(cores = 4)
```

```{r}
tissue =pData(dat)$Tissue
X= model.matrix(~tissue)
index = which(seqnames(dat)=="chr22")
dat = dat[index,] ## for illustrative purposes
res=bumphunter(dat,X,cutoff=0.1,B=1000)
head(res$tab)
```


```{r,message=FALSE}
library(rafalib)
library(AnnotationHub)
cgi = AnnotationHub()[["AH5086"]]
```

```{r}
tab = res$tab[res$tab$fwer <= 0.05,]
tab = makeGRangesFromDataFrame(tab,keep.extra.columns = TRUE)

map=distanceToNearest(tab,cgi)
d = mcols(map)$distance
prop.table( table( cut(as.numeric(d),c(0,1,2000,5000,Inf),include.lowest=TRUE,right=FALSE) ))

null =  granges(dat)
nulltab = makeGRangesFromDataFrame(null,keep.extra.columns = TRUE)

nullmap=distanceToNearest(nulltab,cgi)
nulld = mcols(nullmap)$distance
prop.table( table( cut(nulld,c(0,1,2000,5000,Inf),include.lowest=TRUE,right=FALSE) ))
```

```{r}
beta = getBeta(dat)
cols = as.factor(pData(dat)$Tissue)

tab = tab[order(-mcols(tab)$area)]
tab = tab+3000 ##add 3000 to each side
mypar(1,1)
i=17
dataIndex = which(granges(dat)%over%tab[i])
cgiIndex = which(cgi%over%tab[i])
thecgi = cgi[cgiIndex]
    
pos = start(dat)[dataIndex]
xlim=range(c(pos,start(thecgi),end(thecgi)) )
  
y = beta[dataIndex,]
  
matplot(pos,y,col=as.numeric(cols) , xlim=xlim, ylim=c(0,1),ylab="Methylation")  
apply(cbind(start(thecgi),end(thecgi)),1,function(x) segments(x[1],0,x[2],0,lwd=4,col=3))

plot(pos,res$fitted[dataIndex],xlim=xlim,ylim=c(-0.4,0.4))
abline(h=0)
apply(cbind(start(thecgi),end(thecgi)),1,function(x) segments(x[1],0,x[2],0,lwd=4,col=3))

```

```{r}
table(getIslandStatus(dat))
```










